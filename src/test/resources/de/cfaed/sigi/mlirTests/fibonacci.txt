module {
    // fib_naive: int -> int
    func.func @fib_naive(%e0: !sigi.stack) -> !sigi.stack {
        // -> n;
        %e1, %1_n = sigi.pop %e0: i32 // n
        %e2 = sigi.push %e1, %1_n: i32 // push n
        %2 = arith.constant 1: i32
        %e3 = sigi.push %e2, %2: i32
        // <=
        %e4, %3 = sigi.pop %e3: i32
        %e5, %4 = sigi.pop %e4: i32
        %5 = arith.cmpi "sle", %3, %4: i32
        %e6 = sigi.push %e5, %5: i1
        %6 = closure.box [] (%e7 : !sigi.stack) -> !sigi.stack { // -> int
            %7 = arith.constant 1: i32
            %e8 = sigi.push %e7, %7: i32
            closure.return %e8: !sigi.stack
        }
        %e9 = sigi.push %e6, %6: !closure.box<(!sigi.stack) -> !sigi.stack>
        %9 = closure.box [%8_n = %1_n : i32] (%e10 : !sigi.stack) -> !sigi.stack { // -> int
            %e11 = sigi.push %e10, %8_n: i32 // push n
            %10 = arith.constant 2: i32
            %e12 = sigi.push %e11, %10: i32
            // -
            %e13, %11 = sigi.pop %e12: i32
            %e14, %12 = sigi.pop %e13: i32
            %13 = arith.subi %11, %12: i32
            %e15 = sigi.push %e14, %13: i32
            %e16 = func.call @fib_naive(%e15) : (!sigi.stack) -> !sigi.stack // int -> int
            %e17 = sigi.push %e16, %8_n: i32 // push n
            %14 = arith.constant 1: i32
            %e18 = sigi.push %e17, %14: i32
            // -
            %e19, %15 = sigi.pop %e18: i32
            %e20, %16 = sigi.pop %e19: i32
            %17 = arith.subi %15, %16: i32
            %e21 = sigi.push %e20, %17: i32
            %e22 = func.call @fib_naive(%e21) : (!sigi.stack) -> !sigi.stack // int -> int
            // +
            %e23, %18 = sigi.pop %e22: i32
            %e24, %19 = sigi.pop %e23: i32
            %20 = arith.addi %18, %19: i32
            %e25 = sigi.push %e24, %20: i32
            closure.return %e25: !sigi.stack
        }
        %e26 = sigi.push %e9, %9: !closure.box<(!sigi.stack) -> !sigi.stack>
        %e27 = func.call @":if:"(%e26) : (!sigi.stack) -> !sigi.stack // bool, (-> int), (-> int) -> int
        return %e27: !sigi.stack
    }
    // fib_tailrec: int -> int
    func.func @fib_tailrec(%e0: !sigi.stack) -> !sigi.stack {
        %1 = arith.constant 1: i32
        %e1 = sigi.push %e0, %1: i32
        %2 = arith.constant 1: i32
        %e2 = sigi.push %e1, %2: i32
        %e3 = func.call @fib_tailrec_helper(%e2) : (!sigi.stack) -> !sigi.stack // int, int, int -> int
        return %e3: !sigi.stack
    }
    // fib_tailrec_helper: int, int, int -> int
    func.func @fib_tailrec_helper(%e0: !sigi.stack) -> !sigi.stack {
        // -> n, a, b;
        %e1, %1_n = sigi.pop %e0: i32 // n
        %e2, %2_a = sigi.pop %e1: i32 // a
        %e3, %3_b = sigi.pop %e2: i32 // b
        %e4 = sigi.push %e3, %1_n: i32 // push n
        %4 = arith.constant 0: i32
        %e5 = sigi.push %e4, %4: i32
        // =
        %e6, %5 = sigi.pop %e5: i32
        %e7, %6 = sigi.pop %e6: i32
        %7 = arith.cmpi "eq", %5, %6: i32
        %e8 = sigi.push %e7, %7: i1
        %9 = closure.box [%8_a = %2_a : i32] (%e9 : !sigi.stack) -> !sigi.stack { // -> int
            %e10 = sigi.push %e9, %8_a: i32 // push a
            closure.return %e10: !sigi.stack
        }
        %e11 = sigi.push %e8, %9: !closure.box<(!sigi.stack) -> !sigi.stack>
        %11 = closure.box [%10_n = %1_n : i32] (%e12 : !sigi.stack) -> !sigi.stack { // -> int
            %e13 = sigi.push %e12, %10_n: i32 // push n
            %12 = arith.constant 1: i32
            %e14 = sigi.push %e13, %12: i32
            // =
            %e15, %13 = sigi.pop %e14: i32
            %e16, %14 = sigi.pop %e15: i32
            %15 = arith.cmpi "eq", %13, %14: i32
            %e17 = sigi.push %e16, %15: i1
            %17 = closure.box [%16_b = %3_b : i32] (%e18 : !sigi.stack) -> !sigi.stack { // -> int
                %e19 = sigi.push %e18, %16_b: i32 // push b
                closure.return %e19: !sigi.stack
            }
            %e20 = sigi.push %e17, %17: !closure.box<(!sigi.stack) -> !sigi.stack>
            %21 = closure.box [%18_a = %2_a : i32, %19_b = %3_b : i32, %20_n = %10_n : i32] (%e21 : !sigi.stack) -> !sigi.stack { // -> int
                %e22 = sigi.push %e21, %20_n: i32 // push n
                %22 = arith.constant 1: i32
                %e23 = sigi.push %e22, %22: i32
                // -
                %e24, %23 = sigi.pop %e23: i32
                %e25, %24 = sigi.pop %e24: i32
                %25 = arith.subi %23, %24: i32
                %e26 = sigi.push %e25, %25: i32
                %e27 = sigi.push %e26, %19_b: i32 // push b
                %e28 = sigi.push %e27, %18_a: i32 // push a
                %e29 = sigi.push %e28, %19_b: i32 // push b
                // +
                %e30, %26 = sigi.pop %e29: i32
                %e31, %27 = sigi.pop %e30: i32
                %28 = arith.addi %26, %27: i32
                %e32 = sigi.push %e31, %28: i32
                %e33 = func.call @fib_tailrec_helper(%e32) : (!sigi.stack) -> !sigi.stack // int, int, int -> int
                closure.return %e33: !sigi.stack
            }
            %e34 = sigi.push %e20, %21: !closure.box<(!sigi.stack) -> !sigi.stack>
            %e35 = func.call @":if:"(%e34) : (!sigi.stack) -> !sigi.stack // bool, (-> int), (-> int) -> int
            closure.return %e35: !sigi.stack
        }
        %e36 = sigi.push %e11, %11: !closure.box<(!sigi.stack) -> !sigi.stack>
        %e37 = func.call @":if:"(%e36) : (!sigi.stack) -> !sigi.stack // bool, (-> int), (-> int) -> int
        return %e37: !sigi.stack
    }
    // __main__: ->
    func.func @__main__(%e0: !sigi.stack) -> !sigi.stack {
        %1 = arith.constant 20: i32
        %e1 = sigi.push %e0, %1: i32
        %e2 = func.call @fib_tailrec(%e1) : (!sigi.stack) -> !sigi.stack // int -> int
        %2 = arith.constant 20: i32
        %e3 = sigi.push %e2, %2: i32
        %e4 = func.call @fib_naive(%e3) : (!sigi.stack) -> !sigi.stack // int -> int
        // =
        %e5, %3 = sigi.pop %e4: i32
        %e6, %4 = sigi.pop %e5: i32
        %5 = arith.cmpi "eq", %3, %4: i32
        %e7 = sigi.push %e6, %5: i1
        %e8 = func.call @show(%e7) : (!sigi.stack) -> !sigi.stack // bool ->
        return %e8: !sigi.stack
    }
}
