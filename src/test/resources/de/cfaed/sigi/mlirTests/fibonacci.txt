module {
    // fib_naive: int -> int
    func.func @fib_naive(%e0: !sigi.stack) -> !sigi.stack {
        %e1, %1 = sigi.pop %e0: i32 // n
        %e2 = sigi.push %e1, %1: i32 // n
        %2 = arith.constant 1: i32
        %e3 = sigi.push %e2, %2: i32
        %e4, %3 = sigi.pop %e3: i32
        %e5, %4 = sigi.pop %e4: i32
        %5 = arith.cmpi "sle", %3, %4: i32
        %e6 = sigi.push %e5, %5: i1
        %6 = closure.box [] (%e7 : !sigi.stack) -> !sigi.stack { // -> int
            %7 = arith.constant 1: i32
            %e8 = sigi.push %e7, %7: i32
            closure.return %e8: !sigi.stack
        }
        %e9 = sigi.push %e6, %6: !closure.box<(!sigi.stack) -> !sigi.stack>
        %9 = closure.box [%8 = %1 : i32] (%e10 : !sigi.stack) -> !sigi.stack { // -> int
            %e11 = sigi.push %e10, %8: i32 // n
            %10 = arith.constant 2: i32
            %e12 = sigi.push %e11, %10: i32
            %e13, %11 = sigi.pop %e12: i32
            %e14, %12 = sigi.pop %e13: i32
            %13 = arith.subi %11, %12: i32
            %e15 = sigi.push %e14, %13: i32
            %e16 = func.call @fib_naive(%e15) : (!sigi.stack) -> !sigi.stack
            %e17 = sigi.push %e16, %8: i32 // n
            %14 = arith.constant 1: i32
            %e18 = sigi.push %e17, %14: i32
            %e19, %15 = sigi.pop %e18: i32
            %e20, %16 = sigi.pop %e19: i32
            %17 = arith.subi %15, %16: i32
            %e21 = sigi.push %e20, %17: i32
            %e22 = func.call @fib_naive(%e21) : (!sigi.stack) -> !sigi.stack
            %e23, %18 = sigi.pop %e22: i32
            %e24, %19 = sigi.pop %e23: i32
            %20 = arith.addi %18, %19: i32
            %e25 = sigi.push %e24, %20: i32
            closure.return %e25: !sigi.stack
        }
        %e26 = sigi.push %e9, %9: !closure.box<(!sigi.stack) -> !sigi.stack>
        %e27 = func.call @":if:"(%e26) : (!sigi.stack) -> !sigi.stack
        return %e27: !sigi.stack
    }
    // fib_tailrec: int -> int
    func.func @fib_tailrec(%e0: !sigi.stack) -> !sigi.stack {
        %1 = arith.constant 1: i32
        %e1 = sigi.push %e0, %1: i32
        %2 = arith.constant 1: i32
        %e2 = sigi.push %e1, %2: i32
        %e3 = func.call @fib_tailrec_helper(%e2) : (!sigi.stack) -> !sigi.stack
        return %e3: !sigi.stack
    }
    // fib_tailrec_helper: int, int, int -> int
    func.func @fib_tailrec_helper(%e0: !sigi.stack) -> !sigi.stack {
        %e1, %1 = sigi.pop %e0: i32 // n
        %e2, %2 = sigi.pop %e1: i32 // a
        %e3, %3 = sigi.pop %e2: i32 // b
        %e4 = sigi.push %e3, %1: i32 // n
        %4 = arith.constant 0: i32
        %e5 = sigi.push %e4, %4: i32
        %e6, %5 = sigi.pop %e5: i32
        %e7, %6 = sigi.pop %e6: i32
        %7 = arith.cmpi "eq", %5, %6: i32
        %e8 = sigi.push %e7, %7: i1
        %9 = closure.box [%8 = %2 : i32] (%e9 : !sigi.stack) -> !sigi.stack { // -> int
            %e10 = sigi.push %e9, %8: i32 // a
            closure.return %e10: !sigi.stack
        }
        %e11 = sigi.push %e8, %9: !closure.box<(!sigi.stack) -> !sigi.stack>
        %11 = closure.box [%10 = %1 : i32] (%e12 : !sigi.stack) -> !sigi.stack { // -> int
            %e13 = sigi.push %e12, %10: i32 // n
            %12 = arith.constant 1: i32
            %e14 = sigi.push %e13, %12: i32
            %e15, %13 = sigi.pop %e14: i32
            %e16, %14 = sigi.pop %e15: i32
            %15 = arith.cmpi "eq", %13, %14: i32
            %e17 = sigi.push %e16, %15: i1
            %17 = closure.box [%16 = %3 : i32] (%e18 : !sigi.stack) -> !sigi.stack { // -> int
                %e19 = sigi.push %e18, %16: i32 // b
                closure.return %e19: !sigi.stack
            }
            %e20 = sigi.push %e17, %17: !closure.box<(!sigi.stack) -> !sigi.stack>
            %19 = closure.box [%18 = %10 : i32] (%e21 : !sigi.stack) -> !sigi.stack { // -> int
                %e22 = sigi.push %e21, %18: i32 // n
                %20 = arith.constant 1: i32
                %e23 = sigi.push %e22, %20: i32
                %e24, %21 = sigi.pop %e23: i32
                %e25, %22 = sigi.pop %e24: i32
                %23 = arith.subi %21, %22: i32
                %e26 = sigi.push %e25, %23: i32
                %e27 = sigi.error %e26, {msg="undefined name 'b'"}
                %e28 = sigi.error %e27, {msg="undefined name 'a'"}
                %e29 = sigi.error %e28, {msg="undefined name 'b'"}
                %e30, %24 = sigi.pop %e29: i32
                %e31, %25 = sigi.pop %e30: i32
                %26 = arith.addi %24, %25: i32
                %e32 = sigi.push %e31, %26: i32
                %e33 = func.call @fib_tailrec_helper(%e32) : (!sigi.stack) -> !sigi.stack
                closure.return %e33: !sigi.stack
            }
            %e34 = sigi.push %e20, %19: !closure.box<(!sigi.stack) -> !sigi.stack>
            %e35 = func.call @":if:"(%e34) : (!sigi.stack) -> !sigi.stack
            closure.return %e35: !sigi.stack
        }
        %e36 = sigi.push %e11, %11: !closure.box<(!sigi.stack) -> !sigi.stack>
        %e37 = func.call @":if:"(%e36) : (!sigi.stack) -> !sigi.stack
        return %e37: !sigi.stack
    }
    // __main__: ->
    func.func @__main__(%e0: !sigi.stack) -> !sigi.stack {
        %1 = arith.constant 20: i32
        %e1 = sigi.push %e0, %1: i32
        %e2 = func.call @fib_tailrec(%e1) : (!sigi.stack) -> !sigi.stack
        %2 = arith.constant 20: i32
        %e3 = sigi.push %e2, %2: i32
        %e4 = func.call @fib_naive(%e3) : (!sigi.stack) -> !sigi.stack
        %e5, %3 = sigi.pop %e4: i32
        %e6, %4 = sigi.pop %e5: i32
        %5 = arith.cmpi "eq", %3, %4: i32
        %e7 = sigi.push %e6, %5: i1
        %e8 = func.call @show(%e7) : (!sigi.stack) -> !sigi.stack
        return %e8: !sigi.stack
    }
}
